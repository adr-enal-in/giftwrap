// Generated by CoffeeScript 1.3.3
(function() {
  var Metalib, Queue, SETTINGS, app, automaticallyAddToItunes, cleanup, copyToItunes, express, ffmpeg, fs, http, iTunesFolder, path, queue, routes, startStopDaemon, trashFolder, watch, watchFileExt, watchFolder, _getAudioCodec, _getFfmpegProfile, _getVideoCodec, _home, _moveToItunes, _processVideo, _trashSourceFile, _validFiletype, _videoMetadata;

  SETTINGS = {};

  SETTINGS.watchFileExt = watchFileExt = ["mkv", "ts", "m2ts", "avi"];

  cleanup = false;

  automaticallyAddToItunes = true;

  copyToItunes = true;

  SETTINGS.webInterface = true;

  SETTINGS.watchFolder = watchFolder = "./process";

  fs = require('fs');

  http = require('http');

  path = require('path');

  watch = require('watch');

  ffmpeg = require('fluent-ffmpeg');

  express = require('express');

  Metalib = require('fluent-ffmpeg').Metadata;

  startStopDaemon = require('start-stop-daemon');

  Queue = require("./lib/queue");

  queue = new Queue["class"]();

  /*
  Process = require("./lib/process")
  process = new Process.class({
    queue: queue
    ffmpeg: ffmpeg
    addToItunes: automaticallyAddToItunes
    copyToItunes: copyToItunes
  })
  */


  _videoMetadata = {};

  _home = process.env.HOME;

  iTunesFolder = _home + "/Music/iTunes/iTunes Media/Automatically Add to iTunes/";

  trashFolder = _home + "/.Trash/";

  _getFfmpegProfile = function(file, callback) {
    return ffmpeg.call(["-i " + file], function(params, params2) {
      console.log(params, params2);
      if (typeof callback === "function") {
        return callback();
      }
    });
  };

  _getAudioCodec = function(metadata) {
    if (metadata === undefined) {
      metadata = _videoMetadata;
    }
    if (metadata.audio.codec === "aac") {
      return "copy";
    } else {
      return "aac";
    }
  };

  _getVideoCodec = function(metadata) {
    if (metadata === undefined) {
      metadata = _videoMetadata;
    }
    if (metadata.video.codec === "h264") {
      return "copy";
    } else {
      return "libx264";
    }
  };

  _processVideo = function() {
    var options, outputFile, outputFilename, proc, sourcePath;
    options = {};
    options.outputExt = "mp4";
    options.audioBitrate = "384k";
    options.videoCodec = queue.q[queue.current].x_video_codec;
    options.audioCodec = queue.q[queue.current].x_audio_codec;
    options.source = queue.q[queue.current].file;
    options.position = queue.current;
    queue.setStart(options.position);
    sourcePath = watchFolder + "/" + options.source;
    outputFilename = options.source.replace(/\.[a-z0-9]+$/i, "." + options.outputExt);
    outputFile = "output/" + outputFilename;
    return proc = new ffmpeg({
      source: sourcePath,
      timeout: 60 * 60
    }).withVideoCodec(options.videoCodec).withAudioCodec(options.audioCodec).withAudioBitrate(options.audioBitrate).addOption("-strict", "-2").onProgress(function(progress) {
      console.log(progress.percent);
      return queue.updateProgress(Math.round(progress.percent));
    }).toFormat(options.outputExt).saveToFile(outputFile, function(retcode, error) {
      console.log("- File successfully processed to " + outputFile);
      queue.setEnd(options.position);
      queue.updateStatus("finished", options.position);
      console.log('_trashSourceFile', options.source, sourcePath);
      if (cleanup) {
        _trashSourceFile(sourcePath, sourcePath);
      }
      console.log('_moveToItunes', outputFile, outputFilename);
      if (automaticallyAddToItunes) {
        _moveToItunes(outputFile, outputFilename);
      }
      if (queue.next()) {
        return _processVideo();
      }
    });
  };

  _moveToItunes = function(source, destination) {
    var destinationFile;
    destinationFile = iTunesFolder + destination;
    return fs.rename(source, destinationFile, function(error) {
      if (error) {
        return console.error(error);
      } else {
        return console.log("- Moved output file to iTunes library folder");
      }
    });
  };

  _trashSourceFile = function(source, destination) {
    var destinationFile;
    destinationFile = trashFolder + destination;
    return fs.rename(source, destinationFile, function(error) {
      if (error) {
        return console.error(error);
      } else {
        return console.log("- Moved source file to trash");
      }
    });
  };

  _validFiletype = function(file) {
    var i, regex;
    for (i in watchFileExt) {
      regex = new RegExp("." + watchFileExt[i] + "$", "i");
      if (file.match(regex)) {
        return true;
      }
    }
    return false;
  };

  startStopDaemon({}, function() {
    return watch.createMonitor(watchFolder, function(monitor) {
      monitor.on("created", function(file, stat) {
        var filename, metaObject, pieces;
        pieces = file.split("/");
        filename = pieces[pieces.length - 1];
        metaObject = new Metalib(file);
        return metaObject.get(function(metadata, err) {
          var inQueueAlready;
          if (!_validFiletype(filename)) {
            return;
          }
          _videoMetadata = metadata;
          inQueueAlready = queue["in"](filename);
          if (!inQueueAlready) {
            queue.add({
              filename: filename,
              x_audio_codec: _getAudioCodec(metadata),
              x_video_codec: _getVideoCodec(metadata)
            });
          }
          if (inQueueAlready) {
            return;
          }
          if (!queue.running) {
            return _processVideo();
          }
        });
      });
      return monitor.on("changed", function(file, curr, prev) {
        var filename, metaObject, pieces;
        pieces = file.split("/");
        filename = pieces[pieces.length - 1];
        metaObject = new Metalib(file);
        return metaObject.get(function(metadata, err) {
          var inQueueAlready;
          if (!_validFiletype(filename)) {
            return;
          }
          _videoMetadata = metadata;
          inQueueAlready = queue["in"](filename);
          if (!inQueueAlready) {
            queue.add({
              filename: filename,
              x_audio_codec: _getAudioCodec(metadata),
              x_video_codec: _getVideoCodec(metadata)
            });
          }
          if (inQueueAlready) {
            return;
          }
          if (!queue.running) {
            return _processVideo();
          }
        });
      });
    });
  });

  app = express();

  routes = require("./web/routes");

  app.configure(function() {
    app.set("port", process.env.PORT || 4000);
    app.set("views", __dirname + "/web/views");
    app.set("view engine", "ejs");
    app.use(express.favicon());
    app.use(express.bodyParser());
    app.use(express.methodOverride());
    app.use(app.router);
    return app.use(express["static"](path.join(__dirname, "public")));
  });

  app.configure("development", function() {
    return app.use(express.errorHandler());
  });

  app.get("/", function(req, res) {
    return res.render('index', {
      queue: queue.dump()
    });
  });

  app.get("/settings", function(req, res) {
    return res.render('settings', {
      settings: SETTINGS
    });
  });

  if (SETTINGS.webInterface) {
    http.createServer(app).listen(app.get("port"), function() {
      return console.log("Express server listening on port " + app.get("port"));
    });
  }

}).call(this);
