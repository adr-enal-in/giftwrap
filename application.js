// Generated by CoffeeScript 1.3.3
(function() {
  var Metalib, Queue, app, automaticallyAddToItunes, cleanup, copyToItunes, express, ffmpeg, fs, http, iTunesFolder, path, queue, redistogo_url, routes, startStopDaemon, trashFolder, watch, watchFileExt, watchFolder, web_interface, _conversionProgress, _getAudioCodec, _getFfmpegProfile, _getVideoCodec, _home, _moveToItunes, _processVideo, _trashSourceFile, _validFiletype, _videoMetadata;

  watchFileExt = ["mkv", "ts", "m2ts", "avi"];

  cleanup = false;

  automaticallyAddToItunes = true;

  copyToItunes = true;

  web_interface = false;

  redistogo_url = "";

  watchFolder = "./process";

  fs = require('fs');

  http = require('http');

  path = require('path');

  watch = require('watch');

  ffmpeg = require('fluent-ffmpeg');

  express = require('express');

  Metalib = require('fluent-ffmpeg').Metadata;

  startStopDaemon = require('start-stop-daemon');

  Queue = require("./lib/queue");

  queue = new Queue["class"]();

  /*
  Process = require("./lib/process")
  process = new Process.class({
    queue: queue
    ffmpeg: ffmpeg
    addToItunes: automaticallyAddToItunes
    copyToItunes: copyToItunes
  })
  */


  _videoMetadata = {};

  _conversionProgress = 0;

  _home = process.env.HOME;

  iTunesFolder = _home + "/Music/iTunes/iTunes Media/Automatically Add to iTunes/";

  trashFolder = _home + "/.Trash/";

  _getFfmpegProfile = function(file, callback) {
    return ffmpeg.call(["-i " + file], function(params, params2) {
      console.log(params, params2);
      if (typeof callback === "function") {
        return callback();
      }
    });
  };

  _getAudioCodec = function(metadata) {
    if (metadata === undefined) {
      metadata = _videoMetadata;
    }
    if (metadata.audio.codec === "aac") {
      return "copy";
    } else {
      return "aac";
    }
  };

  _getVideoCodec = function(metadata) {
    if (metadata === undefined) {
      metadata = _videoMetadata;
    }
    if (metadata.video.codec === "h264") {
      return "copy";
    } else {
      return "libx264";
    }
  };

  _processVideo = function(options) {
    var outputFile, outputFilename, proc, sourcePath;
    options.outputExt = "mp4";
    options.audioBitrate = "384k";
    queue.setStart(options.position);
    sourcePath = watchFolder + "/" + options.source;
    outputFilename = options.source.replace(/\.[a-z0-9]+$/i, "." + options.outputExt);
    outputFile = "output/" + outputFilename;
    return proc = new ffmpeg({
      source: sourcePath,
      timeout: 60 * 60
    }).withVideoCodec(options.videoCodec).withAudioCodec(options.audioCodec).withAudioBitrate(options.audioBitrate).addOption("-strict", "-2").onProgress(function(progress) {
      var localProgress;
      localProgress = Math.round(progress.percent);
      queue.updateProgress(progress, options.position);
      return _conversionProgress = localProgress;
    }).toFormat(options.outputExt).saveToFile(outputFile, function(retcode, error) {
      console.log("- File successfully processed to " + outputFile);
      queue.setEnd(options.position);
      queue.updateStatus("finished", options.position);
      console.log('_trashSourceFile', options.source, sourcePath);
      if (cleanup && !error) {
        _trashSourceFile(sourcePath, sourcePath);
      }
      console.log('_moveToItunes', outputFile, outputFilename);
      if (automaticallyAddToItunes && !error) {
        return _moveToItunes(outputFile, outputFilename);
      }
    });
  };

  _moveToItunes = function(source, destination) {
    var destinationFile;
    destinationFile = iTunesFolder + destination;
    return fs.rename(source, destinationFile, function(error) {
      if (error) {
        return console.error(error);
      } else {
        return console.log("- Moved output file to iTunes library folder");
      }
    });
  };

  _trashSourceFile = function(source, destination) {
    var destinationFile;
    destinationFile = trashFolder + destination;
    return fs.rename(source, destinationFile, function(error) {
      if (error) {
        return console.error(error);
      } else {
        return console.log("- Moved source file to trash");
      }
    });
  };

  _validFiletype = function(file) {
    var i, regex;
    for (i in watchFileExt) {
      regex = new RegExp("." + watchFileExt[i] + "$", "i");
      if (file.match(regex)) {
        return true;
      }
    }
    return false;
  };

  startStopDaemon({}, function() {
    return watch.createMonitor(watchFolder, function(monitor) {
      monitor.on("created", function(file, stat) {
        var filename, inQueueAlready, metaObject, pieces, position;
        pieces = file.split("/");
        filename = pieces[pieces.length - 1];
        inQueueAlready = queue["in"](filename);
        if (!inQueueAlready) {
          position = queue.add(filename);
        }
        if (!_validFiletype(filename) || inQueueAlready) {
          return;
        }
        metaObject = new Metalib(file);
        return metaObject.get(function(metadata, err) {
          _videoMetadata = metadata;
          return _processVideo({
            source: filename,
            audioCodec: _getAudioCodec(metadata),
            videoCodec: _getVideoCodec(metadata),
            position: position
          });
        });
      });
      return monitor.on("changed", function(file, curr, prev) {
        var i, metaObject, re, _results;
        _results = [];
        for (i in watchFileExt) {
          re = new RegExp("." + watchFileExt[i] + "$", "i");
          if (file.match(re)) {
            metaObject = new Metalib(file);
            _results.push(metaObject.get(function(metadata, err) {}));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      });
    });
  });

  app = express();

  routes = require("./web/routes");

  app.configure(function() {
    app.set("port", process.env.PORT || 4000);
    app.set("views", __dirname + "/web/views");
    app.set("view engine", "ejs");
    app.use(express.favicon());
    app.use(express.logger("dev"));
    app.use(express.bodyParser());
    app.use(express.methodOverride());
    app.use(app.router);
    return app.use(express["static"](path.join(__dirname, "public")));
  });

  app.configure("development", function() {
    return app.use(express.errorHandler());
  });

  app.get("/", function(req, res) {
    return res.render('index', {
      queue: queue.dump()
    });
  });

  http.createServer(app).listen(app.get("port"), function() {
    return console.log("Express server listening on port " + app.get("port"));
  });

}).call(this);
