// Generated by CoffeeScript 1.3.3
(function() {
  var Metalib, ffmpeg, watch, watchFileExt, _getAudioCodec, _getFfmpegProfile, _getVideoCodec, _lastEventTime, _notDuplicateEvent, _processVideo, _validFiletype, _videoMetadata;

  watch = require("watch");

  ffmpeg = require("fluent-ffmpeg");

  Metalib = require("fluent-ffmpeg").Metadata;

  watchFileExt = ["mkv", "2t", "m2ts"];

  _videoMetadata = {};

  _lastEventTime = 0;

  _getFfmpegProfile = function(file, callback) {
    return ffmpeg.call(["-i " + file], function(params, params2) {
      console.log(params, params2);
      if (typeof callback === "function") {
        return callback();
      }
    });
  };

  _getAudioCodec = function(metadata) {
    if (metadata === undefined) {
      metadata = _videoMetadata;
    }
    if (metadata.audio.codec === "aac") {
      return "copy";
    } else {
      return "aac";
    }
  };

  _getVideoCodec = function(metadata) {
    if (metadata === undefined) {
      metadata = _videoMetadata;
    }
    if (metadata.video.codec === "h264") {
      return "copy";
    } else {
      return "libx264";
    }
  };

  _processVideo = function(options) {
    var outputFilename, proc;
    options.outputExt = "mp4";
    options.audioBitrate = "384k";
    outputFilename = options.source.replace(/\.[a-z0-9]+$/i, "." + options.outputExt);
    outputFilename = "output/" + outputFilename.replace(/^[a-z]+\//i, "");
    return proc = new ffmpeg({
      source: options.source,
      timeout: 60 * 60
    }).withVideoCodec(options.videoCodec).withAudioCodec(options.audioCodec).withAudioBitrate(options.audioBitrate).addOption("-strict", "-2").onProgress(function(progress) {
      return console.log("Progress: " + progress);
    }).toFormat(options.outputExt).saveToFile(outputFilename, function(retcode, error) {
      return console.log("SUCCESS: File processed to " + outputFilename + "\n");
    });
  };

  _validFiletype = function(file) {
    var i, regex;
    for (i in watchFileExt) {
      regex = new RegExp("." + watchFileExt[i] + "$", "i");
      if (file.match(regex)) {
        return true;
      }
    }
    return false;
  };

  _notDuplicateEvent = function() {
    return new Date().getTime() - _lastEventTime < 20;
  };

  watch.createMonitor("./process", function(monitor) {
    monitor.on("created", function(file, stat) {
      var metaObject;
      if (!_validFiletype(file) || _notDuplicateEvent()) {
        return;
      }
      metaObject = new Metalib(file);
      metaObject.get(function(metadata, err) {
        _videoMetadata = metadata;
        console.log("########", "Starting to process " + file);
        return _processVideo({
          source: file,
          audioCodec: _getAudioCodec(metadata),
          videoCodec: _getVideoCodec(metadata)
        });
      });
      return _lastEventTime = new Date().getTime();
    });
    return monitor.on("changed", function(file, curr, prev) {
      var i, metaObject, re, _results;
      _results = [];
      for (i in watchFileExt) {
        re = new RegExp("." + watchFileExt[i] + "$", "i");
        if (file.match(re)) {
          metaObject = new Metalib(file);
          _results.push(metaObject.get(function(metadata, err) {}));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    });
  });

}).call(this);
